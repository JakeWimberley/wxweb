<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
	<link href="https://fonts.googleapis.com/css?family=Kanit" rel="stylesheet">
	<link href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.3.1/leaflet.css" rel="stylesheet">
	<style>
	.bg {
		background-color: black;
	}
	text.fg1 {
		fill: white;
		stroke: none;
	}
	.fg1 {
		color: white;
		stroke: white;
	}
	.fg2 {
		fill: crimson;
		color: crimson;
	}
	#controlContainer {
		margin-bottom: 20px;
	}
	#llPicker {
		height: 270px;
		width: 480px;
		display: inline-block;
	}
	#llReadout {
		background-color: red;
		color: white;
	}
	#queries {
		float: right;
	}
	#graph, #topTitle, #bottomTitle { /* bg */
	}
	#topTitle, #bottomTitle { /* fg1 */
		font-family: 'Kanit', sans-serif;
		padding: 5px;
	}
	#bottomTitle { /* workaround for mysterious gap below SVG */
		position: relative;
		top: -5px;
		font-size: 18px;
	}
	#placeName {
		font-size: 36px;
	}
	#elementName {
		font-size: 36px;
	}
	#timeRangeDesc {
		/* font-style: italic; */
	}
	#officeWebsite {
		font-style: italic;
	}
	#graph text {
		font-family: 'Kanit', sans-serif;
	}
	.clickedValue { /* fg1 */
		font-size: 20px;
		text-anchor: middle;
	}
	.xAxis line, .xAxis path, .wxGridline line { /* fg1 */
		stroke: inherit;
	}
	.xAxis text { /* fg1 */
		stroke: none;
		font-size: 16px;
		text-anchor: end;
	}
	.wxGridline text { /* fg1 */
		stroke: none;
		font-size: 16px;
	}
	.sameWidthAsGraph {
		margin: 0px;
	}
	#footer {
		font-size: 12px;
	}
	</style>
	<script src="https://code.jquery.com/jquery-3.3.1.js"></script>
	<script src="https://d3js.org/d3.v4.min.js"></script>
	<script src="https://momentjs.com/downloads/moment.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.3.1/leaflet.js"></script>
	<script>
	var currentFcst = {};
	var currentLL = {};
	currentLL.latlng = { lat: 35, lng: -82 }; // default location
	var mapPicker, readout;
	var graphDimensions = {
		width: 1600*0.75,
		height: 900*0.6,
		easementTimeAxis: 20,
		gapTimeAxis: 3,
		gapWxGridline: 10,
		gapLeft: 40,
		gapRight: 20
	};
	var daysOfWeek = ['Su','Mo','Tu','We','Th','Fr','Sa'];
	var metFormat = d3.format("2.0f");
	var llFormat = d3.format("6.4f");
	var elementChoices = {
		'temperature': {
			displayName: 'Temperature',
			rawUnit: "°C",
			displayUnit: '°F',
			convert: function(c) { return((c * 9 / 5.) + 32); }
		},
		'dewpoint': {
			displayName: 'Dewpoint',
			rawUnit: "°C",
			displayUnit: '°F',
			convert: function(c) { return((c * 9 / 5.) + 32); }
		},
		'relativeHumidity': {
			displayName: 'Relative Humidity',
			rawUnit: '%',
			displayUnit: '%',
			convert: function(c) { return(c); }
		},
		'apparentTemperature': {
			displayName: 'Apparent Temperature',
			rawUnit: "°C",
			displayUnit: '°F',
			convert: function(c) { return((c * 9 / 5.) + 32); }
		},
		'skyCover': {
			displayName: 'Sky Cover',
			rawUnit: '%',
			displayUnit: '%',
			convert: function(c) { return(c); }
		},
		'windSpeed': {
			displayName: 'Wind Speed',
			rawUnit: 'm/s',
			displayUnit: 'mph',
			convert: function(c) { return(c * 2.237); }
		},
		'windGust': {
			displayName: 'Wind Gust',
			rawUnit: 'm/s',
			displayUnit: 'mph',
			convert: function(c) { return(c * 2.237); }
		},
		'probabilityOfPrecipitation': {
			displayName: 'Chance of Precipitation',
			rawUnit: '%',
			displayUnit: '%',
			convert: function(c) { return(c); }
		},
	};
	function ParsePeriod(v) {
		// v is a string in ISO 8601 duration format
		var s = v.split('/');
		var startTime = moment(s[0]);
		var endTime = moment(s[0]).add(moment.duration(s[1]));
		return [startTime.toDate(),endTime.toDate()];
	}
	function ClearClicks() {
		d3.selectAll(".clickedValue").remove();
	}
	function FailBlog(why) {
		$("#placeName").text("Failed " + why + " request...please try again later");
		$("#elementName").text(" :-(");
	}
	function TimeLabel(d) {
		var s = d3.timeFormat('%a %I%p')(d); // e.g. "Fri 09AM"
		// replace AM with 'a' and PM with 'p'
		s = s.replace(/([AP])M/,function(match,p1) {
			return p1.toLowerCase();
		});
		// lob last letter off 3-letter day abbrev
		s = s.replace(/([A-Z][a-z])[a-z]/,'$1');
		// remove leading zero from hour
		s = s.replace(/0([0-9])/,'$1');
		return s;
	}
	function DrawForecast(f,e,tr) {
		/*
			f: forecast object as generated by ForecastForLatLon()
			e: wx element name as given in JSON e.g. https://api.weather.gov/gridpoints/GSP/77,50
			tr: optional time range [Date(),Date()]
			    if not specified, defaults to full range of data
		*/
		var fullTimeRange = ParsePeriod(f.validRange);
		var displayTimeRange = tr ? tr : fullTimeRange;
		// Remove the parts of the forecast that fall outside display range.
		var fWeather = f.wx[e].values.filter(function(i) {
			var tstep = ParsePeriod(i.validTime);
			if (tstep[1] <= displayTimeRange[0] || // this timestep ends at or before start of requested range OR
			    tstep[0] >= displayTimeRange[1]) { // this timestep begins at or after end of requested range
				return false; // reject
			} else { return true; } // keep
		});
		// allValidPeriods is a list comprised of [startDate,endDate] values for each timestep.
		// It will be used to place the weather data along the X axis.
		var allValidPeriods = fWeather.map(i => ParsePeriod(i.validTime));
		// elementValues is the list of meteorological values only.
		// It will determine the Y axis.
		var elementValues = fWeather.map(i => elementChoices[e]["convert"](i.value));
		var ScaleBarHeight,ScaleWxAxis;
		if (e == 'probabilityOfPrecipitation' || e == 'skyCover') { // always 0 to 100%
			ScaleBarHeight = d3.scaleLinear().domain([0,100]).range([5,graphDimensions.height]);
			ScaleWxAxis = d3.scaleLinear().domain([0,100]).range([graphDimensions.height,1]);
		} else {
			ScaleBarHeight = d3.scaleLinear().domain([d3.min(elementValues), d3.max(elementValues)]).range([5,graphDimensions.height]);
			ScaleWxAxis = d3.scaleLinear().domain([d3.min(elementValues), d3.max(elementValues)]).range([graphDimensions.height,1]);
		}
		var ScaleClickValue = function(v) {
			if (ScaleBarHeight(v) < 21)
				return (graphDimensions.height - ScaleBarHeight(v) - 4); // above bar
			else
				return (graphDimensions.height - ScaleBarHeight(v) + 24); // within bar
		};
		// Having removed the wx data that totally falls outside the time range,
		// we can use clamp() to trim the periods that cross the range bounds.
		var ScaleBarWidth = d3.scaleTime().domain(displayTimeRange).range([graphDimensions.gapLeft,graphDimensions.width-graphDimensions.gapRight]).clamp(true);
		var timeRangeDescription = moment(displayTimeRange[0]).calendar() + ' to ' + moment(displayTimeRange[1]).calendar();
		d3.select("#officeName").text(f.officeName);
		d3.select("#officeWebsite").text(f.website);
		d3.select("#placeName").text(f.locationName);
		d3.select("#elementName").text(" \u25B8 " + elementChoices[e]["displayName"] + " (" + elementChoices[e]["displayUnit"] + ")");
		d3.select("#timeRangeDesc").text(timeRangeDescription);		
		d3.select("#gridpointUrl").attr("href", f.gridpointUrl).text('View raw data for ' + f.locationName);
		ClearClicks(); // clear any bar values plotted on last draw
		d3.select("g.xAxis").remove();
		d3.select("g.wxGridline").remove();
		var graph = d3.select("#graph")
			.attr("width", graphDimensions.width)
			.attr("height", graphDimensions.height + graphDimensions.easementTimeAxis);
		graph.append("g")
			.attr("class", "xAxis fg1")
			.attr("transform", "translate(0," + (graphDimensions.height + graphDimensions.gapTimeAxis) + ")");
		graph.append("g")
			.attr("class", "wxGridline fg1")
			.attr("transform", "translate(" + graphDimensions.gapWxGridline + ",0)");
		d3.select("#imageContainer").attr("style", "width: " + graphDimensions.width + "px");
		graph.selectAll("polygon").remove(); // HACK so gridlines won't draw on top after bars.update()
		var bars = graph.selectAll("polygon")
			.attr("class", "fg2")
			.data(elementValues)
			.attr("points", function(d,i) { var attr = ScaleBarWidth(allValidPeriods[i][0]) + ',' + graphDimensions.height + ' '
									 + (ScaleBarWidth(allValidPeriods[i][1]) - 1) + ',' + graphDimensions.height + ' '
									 + (ScaleBarWidth(allValidPeriods[i][1]) - 1) + ',' + (graphDimensions.height - ScaleBarHeight(d)) + ' '
									 + ScaleBarWidth(allValidPeriods[i][0]) + ',' + (graphDimensions.height - ScaleBarHeight(d)); 
								return attr; } )
			.on("click", function(d,i) { graph.append("text")
											.attr("class", "clickedValue fg1")
											.attr("y", ScaleClickValue(d))
											.attr("x", ScaleBarWidth(d3.mean(allValidPeriods[i])))
											.text(metFormat(d)); });
		bars.exit().remove();
		bars.enter().append("polygon")
			.attr("class", "fg2")
			.attr("points", function(d,i) { var attr = ScaleBarWidth(allValidPeriods[i][0]) + ',' + graphDimensions.height + ' '
									 + (ScaleBarWidth(allValidPeriods[i][1]) - 1) + ',' + graphDimensions.height + ' '
									 + (ScaleBarWidth(allValidPeriods[i][1]) - 1) + ',' + (graphDimensions.height - ScaleBarHeight(d)) + ' '
									 + ScaleBarWidth(allValidPeriods[i][0]) + ',' + (graphDimensions.height - ScaleBarHeight(d)); 
								return attr; } )
			.on("click", function(d,i) { graph.append("text")
											.attr("class", "clickedValue fg1")
											.attr("y", ScaleClickValue(d))											
											.attr("x", ScaleBarWidth(d3.mean(allValidPeriods[i])))
											.text(metFormat(d)); });
		var timeAxis = d3.axisBottom(ScaleBarWidth).tickPadding(1).tickSize(18).tickFormat(TimeLabel);
		//var timeAxis = d3.axisBottom(ScaleBarWidth).tickFormat(d3.timeFormat("%a")).tickPadding(1);
		var wxAxis = d3.axisLeft(ScaleWxAxis).ticks(5);
		d3.selectAll("g.xAxis")
			.call(timeAxis)
			.selectAll("text")
			.attr("class", "fg1")
			.attr("y", 3)
			.attr("x", 3)
			.style("text-anchor","start");
		d3.selectAll("g.wxGridline")
			.call(wxAxis.tickSize(-(graphDimensions.width - graphDimensions.gapWxGridline * 2)))
			.selectAll("text")
			.attr("class", "fg1")
			.attr("y", -8)
			.attr("x", 3)
			.style("text-anchor","start");
		d3.selectAll("g.wxGridline path").remove(); // remove the axis line, and the ticks at the bounds of the data range
	}
	function ForecastForLatLon(lat,lon,e) {
		var fcst = {};
		$("#placeName").text("Loading...");
		$("#elementName").text("");
		$.getJSON(
			'https://api.weather.gov/points/' + lat + ',' + lon,
			function(response) {
				fcst.officeMetadataUrl = response.properties.forecastOffice;
				$.getJSON( // guess this is async and prone to race condition, but it seems to work
					fcst.officeMetadataUrl,
					function(r) {
						if (!('name' in r)) {
							console.log("failed metadata request");
						}
						fcst.officeName = r.name.replace(/\s*NWS\s*/,''); // ILM value is "NWS Wilmington, NC"
						fcst.website = r.sameAs.replace(/https?:\/\//,'');
					}
				).fail(function() { FailBlog('metadata'); });
				fcst.gridpointUrl = response.properties.forecastGridData;
				$.getJSON(
					fcst.gridpointUrl,
					function(response2) {
						fcst.wx = response2.properties;
						fcst.validRange = response2.properties.validTimes;
						//console.log(response.properties.cwa,response.properties.gridX,response.properties.gridY);
						fcst.gridX = response.properties.gridX;
						fcst.gridY = response.properties.gridY;
						fcst.cwa = response.properties.cwa;
						fcst.locationName = response.properties.relativeLocation.properties.city + ', ' + response.properties.relativeLocation.properties.state;
						DrawForecastForQuery();
					}
				).fail(function() { FailBlog('forecast'); });
			}
		).fail(function() { FailBlog('lat-lon'); });
		return fcst;
	}
	// convenience functions
	function ForecastForCurrentLL() {
		console.log('retreiving new fcst for currentLL ' + currentLL.latlng.lat, currentLL.latlng.lng);
		return ForecastForLatLon(currentLL.latlng.lat,currentLL.latlng.lng);
	}
	function DrawForecastForQuery() {
		var qE = $("#queryElement"), qST = $("#queryStartTime"), qET = $("#queryEndTime");
		DrawForecast(currentFcst,qE.val(),[new Date(qST.val()), new Date(qET.val())]);
	}
	</script>
</head>

<p style="font-weight: bold; color: purple"><span style="font-size: 28px; color: black">Hourly Weather Grapher</span> <i>does not work in Internet Explorer</i></p>
<div id="controlContainer">
<div id="llPicker"></div>
<span id="llReadout"></span>
<div id="queries">Plot <select id="queryElement"></select> from <select id="queryStartTime"></select> through <select id="queryEndTime"></select><br>
Click on any bar in the graph to plot its value. <button onclick="ClearClicks()">Clear plotted values</button><br>
If you don't like the city name, click it and you can type in a better one.
</div>
</div>
<div id="imageContainer">
<p id="topTitle" class="bg fg1 sameWidthAsGraph"><span id="placeName" contenteditable="true">Click a location on the map first, </span><span id="elementName">then choose a wx element</span><br><span id="timeRangeDesc">and a time range</span></p>
<svg id="graph" class="bg"></svg><p id="bottomTitle" class="bg fg1 sameWidthAsGraph">National Weather Service &#x25B8; <span id="officeName">Local Forecast Office</span> &#x25B8; <span id="officeWebsite">[URL]</span></p>
</div>
<p id="footer">A Jake Wimberley Production. <a id="gridpointUrl" href="#">Huh?</a></p>

<script>
function GetLLFromClick(e) {
	//console.log('click at ' + e.latlng);
	currentLL.latlng = { lat: e.latlng.lat, lng: e.latlng.lng };
	if (currentLL.marker) currentLL.marker.remove();
	currentLL.marker = L.marker(currentLL.latlng).addTo(mapPicker);
	$("#queryElement").val("temperature");
	currentFcst = ForecastForCurrentLL();
}
function UpdateLLReadout(e) {
	try { $("#llReadout").text('The mouse position is ' + llFormat(e.latlng.lat) + ', ' + llFormat(e.latlng.lng)); }
	catch (err) { $("#llReadout").text(""); }
}

$(function() {
	var qE = $("#queryElement"), qST = $("#queryStartTime"), qET = $("#queryEndTime");
	var periodList = Array.from({length: 15}, (x,i) => i);
	var fcstStart = moment()
						.hour(moment().hour() >= 18 || moment().hour() < 6 ? 18 : 6) // in evening or early morning, first period starts in evening
						.minute(0)
						.second(0)
						.subtract(moment().hour() < 6 ? 1 : 0, 'days'); // in early morning first period started yesterday
	var defaultFcstEnd = moment(fcstStart).add(24,'hours').format();
	mapPicker = L.map('llPicker').setView([currentLL.latlng.lat,currentLL.latlng.lng], 8);
	L.tileLayer('https://a.tile.opentopomap.org/{z}/{x}/{y}.png', {
		attribution: 'opentopomap.org, CC-BY-SA',
		maxZoom: 13,
	}).addTo(mapPicker);
	mapPicker.on('click', GetLLFromClick);
	mapPicker.on('mousemove', UpdateLLReadout);
	mapPicker.on('mouseout', function(e) { UpdateLLReadout(); });
	$.each(elementChoices, function(e) { qE.append($("<option />").val(e).text(elementChoices[e]["displayName"])); });
	// populate time selections by calculating offsets from fcstStart
	$.each(periodList,
		function(e) {
			var _fS1 = moment(fcstStart); // mutable copies
			var _fS2 = moment(fcstStart);
			var t1 = _fS1.add(e*12,'hours');
			var t2 = _fS2.add((e+1)*12,'hours');
			if (t1.format('A') == 'PM') var displayStr = t1.format('dddd') + ' Night';
			else var displayStr = t1.format('dddd');
			qST.append($("<option />").val(t1.format()).text(displayStr));
			qET.append($("<option />").val(t2.format()).text(displayStr)); // since t2 is BEGINNING of next period, name is the same
		});
	qE.change(DrawForecastForQuery);
	qST.change(DrawForecastForQuery);
	qET.change(DrawForecastForQuery);
	qET.val(defaultFcstEnd);
});
</script>
